import regex as re
import shutil

from random import randint
from pathlib import Path
from string import Template

from model.survey import *
from model.question import *
from utils.database import session
from utils.logger import logger
from utils.tools import fisher_yates_shuffle

from localization.locale import type1_locale_data


class SurveyGenerator:

    supported_export_types = ["html", "json"]

    def __init__(self, questions_per_survey, survey_type):
        self.questions_per_survey = questions_per_survey

        if survey_type not in Survey.valid_types:
            logger.error(f"Survey type can be in {Survey.valid_types} but you require {survey_type}.")
            raise ValueError(f"Survey type can be in {Survey.valid_types} but you require {survey_type}.")
        self.survey_type = survey_type

    def generate_all(self, n_surveys=None):
        """
        Generates surveys and saves them to the database.

        Surveys are generated by selecting `questions_per_survey` questions from database using Fisher-Yates shuffling
        algorithm. If `survey_type` is set to `regular` candidate questions are those unassigned to any previously
        generated survey. Otherwise, if `survey_type` is set to `control`, candidate questions are picked from those
        questions already assigned to existing regular surveys.

        :param n_surveys: Maximum number of survey that should be generated. If the requested number is larger then
            a possible number of surveys that can be generated, the method generate as many surveys as it can.
        :return:
        """
        n_original, n_repeated = 0, 0
        while True:     # iterate while there are more questions to include in some of the surveys
            if self.survey_type == "regular":
                questions = Questions.get_unassigned()
                survey = RegularSurvey(auth_page=False)
            else:
                questions = Questions.get_in_regular_survey()
                survey = ControlSurvey(auth_page=False)

            if len(questions) == 0:     # all questions are already added to the survey
                logger.info(f"There are no more unassigned questions satisfying the criteria for '{self.survey_type}' "
                            f"in the database. Finishing.")
                break

            # save a survey to database so that it is assigned valid id
            session.add(survey)
            session.commit()
            shuffled_questions = fisher_yates_shuffle(questions)

            for i in range(0, min(self.questions_per_survey, len(shuffled_questions))):
                question = shuffled_questions[i]
                survey.questions.append(question)
                logger.info(f"Added question {question.id} to survey {survey.id}.")

                if isinstance(survey, RegularSurvey):
                    n_original += 1
                else:
                    n_repeated += 1

            # warn if the survey is assigned less questions then requested
            if len(survey.questions) != self.questions_per_survey:
                logger.warning(f"Survey {survey.id} have {len(survey.questions)} questions instead of "
                               f"{self.questions_per_survey}.")

            # generate survey json and update the survey in the database
            survey.generate()

            # replace survey id placeholders in questions associated to survey with the survey id
            survey.json = survey.json.replace("^_^", str(survey.id))
            session.commit()

            # stop survey generation if required number of surveys is reached
            if n_surveys is not None:
                n_surveys -= 1
                if n_surveys == 0:
                    break

        ssize_inter, ssize_intra = n_original, n_repeated
        if ssize_intra == 0:
            logger.info("")
            logger.info("*" * 100)
            logger.info(
                f"Expected sample size for inter-observer agreement methods is {ssize_inter} (per observer).")
            logger.info(f"Use the reported sample size if you want to check if the sample size is large enough to produce "
                        f"reliable results using inter-observer agreement methods (Cohen's kappa and Kripptendorff's"
                        f" alpha) and significance level, effect size, and statistical power you need. "
                        f"To do that, we recommend using specialized software for sample size calculation, e.g. GPower "
                        f"(https://www.psychologie.hhu.de/arbeitsgruppen/allgemeine-psychologie-und-arbeitspsychologie/gpower), "
                        f"or online calculators such as Sample Size Calculator (https://wnarifin.github.io/ssc_web.html).")
            logger.info("*" * 100)
        else:
            logger.info("")
            logger.info("*" * 100)
            ssize_intra = len(questions)
            logger.info(
                f"Expected sample size for intra-observer agreement methods is {ssize_intra} (per observer).")
            logger.info(
                f"Use the reported sample size if you want to check if the sample size is large enough to produce "
                f"reliable results using intra-observer agreement methods (Cronbach's alpha, ICC, Guttman's lambda) and "
                f"significance level, effect size, and statistical power you need. To do that, we recommend using "
                f"specialized software for sample size calculation, e.g. GPower "
                f"(https://www.psychologie.hhu.de/arbeitsgruppen/allgemeine-psychologie-und-arbeitspsychologie/gpower), "
                f"or online calculators such as Sample Size Calculator (https://wnarifin.github.io/ssc_web.html).")
            logger.info("*" * 100)

    @staticmethod
    def export_surveys(where, export_type="json", survey_type="regular"):
        """

        :param where:
        :param export_type:
        :param survey_type:
        :return:
        """
        # check if directory to export to is ok
        if where is not None:
            if not Path(where).is_dir():
                logger.error(f"Cannot export surveys to {where} because it is not a directory.")
                raise NotADirectoryError(f"Cannot export surveys to {where} because it is not a directory.")
            else:
                logger.info(f"Survey export is enabled. You can find exported surveys in directory '{where}'.")

        # check if export type is valid
        export_type = export_type.lower()
        if export_type not in SurveyGenerator.supported_export_types:
            logger.error(f"Cannot export survey to '{export_type}'. Supported types are "
                         f"{SurveyGenerator.supported_export_types}")
            raise ValueError(f"Cannot export survey to '{export_type}'. Supported types are "
                             f"{SurveyGenerator.supported_export_types}")

        # export content
        surveys = session.query(Survey).where(Survey.type == survey_type).all()
        for survey in surveys:
            if type(survey) == RegularSurvey:
                prefix = "regular"
            else:
                prefix = "control"
            if export_type == "json":
                survey_filename = f"{prefix}-survey-{survey.id}.t1.json"
                target_path = Path(where) / survey_filename
                with open(target_path, "w", encoding="utf8") as fout:
                    fout.write(survey.json)
                    logger.info(f"Survey {survey_filename} saved!")
            else:  # html
                # $head - html head section
                # $body - html body section
                html = Template("""
<html>
                    $head
                    $body
</html>
                """).substitute({
                    "head": SurveyGenerator._generate_html_head_template(),
                    "body": SurveyGenerator._genenerate_html_body_template().substitute({
                        "survey_json": survey.json,
                        "jqueryselector": "$"
                    })
                })
                survey_filename = f"{prefix}-survey-{survey.id}.t1.html"
                target_path = Path(where) / survey_filename
                with open(target_path, "w", encoding="utf8") as fout:
                    fout.write(html)
                    logger.info(f"Survey {survey_filename} saved!")

    @staticmethod
    def _copy_export_images(where, survey):
        # exported surveys work when images are in the same directory as surveys
        # copy images to the location where surveys are exported
        export_img_dir = (Path(where) / "images")
        export_img_dir.mkdir(parents=True, exist_ok=True)
        questions = Questions.get_by_survey(survey.id)
        for q in questions:
            im = q.image
            impath = Path(im.root) / im.filename
            if not Path(export_img_dir / im.filename).is_file():
                shutil.copy(impath, export_img_dir)

    @staticmethod
    def _generate_html_head_template():
        return """ 
  <head> 
    <meta charset="UTF-8">

    <!-- favicon settings --> 
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="site.webmanifest">
    <link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    
    <!-- jquery and survey.jquery -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <link href="https://unpkg.com/survey-jquery@1.8.41/modern.css" type="text/css" rel="stylesheet" />
    <script src="https://unpkg.com/survey-jquery@1.8.41/survey.jquery.min.js"></script>
    
    <!-- zoom script -->
    <!-- see: https://www.w3schools.com/howto/tryit.asp?filename=tryhow_js_image_zoom -->
    <script>
      let DoctorData = {
         //PHP-DOCTOR-DATA-REPLACE
      };
      let SurveyData = {
         //PHP-SURVEY-DATA-REPLACE
      };
      function initViewer(imageId) {
          const viewer = new MedicalImageViewer('#viewer');
          viewer.loadImage(imageId)
      };
     </script>
  </head>
"""

    @staticmethod
    def _genenerate_html_body_template():
        # $survey_json - survey json string saved in a database
        # $jqueryselector - is to be substitutes with "$" as a workaround
        return Template(f"""
<body>
    <!-- replace this with built-in js code -->
    <script src="simpleviewer.js"></script>
    
    <!-- a container where the survey will be inserted -->
    <div id="surveyContainer"></div>
        
    <script>
        Survey.StylesManager.applyTheme("modern");
        var surveyJSON = $survey_json
        // Function to download survey results to a file
      
        function downloadSurveyData(data, filename = 'survey-results.json') {{
            let jsonData = JSON.stringify(data, null, 2); // Pretty print JSON data
            let blob = new Blob([jsonData], {{ type: "application/json" }});
              
            // Create a link element to trigger the download
            let link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
              
            // Programmatically click the link to trigger the download
            document.body.appendChild(link);
            link.click();
              
            // Clean up
            document.body.removeChild(link);
        }}
          
        // Replace the original sendDataToServer function with this
        function sendDataToDisk(sender) {{
            // Serialize the survey data
            let surveyData = sender.data;
            let formattedData = {{
                "ResultCount": 1,
                "HappenedAt": Date.now(),
                "Data": [
                    surveyData
                ]
            }};
    
            surveyFilename = window.location.pathname
            surveyFilename = surveyFilename.substring(surveyFilename.lastIndexOf('/') + 1)
            let responseFilename = 'responses-' + surveyFilename
    
            // Trigger file download with the survey data
            downloadSurveyData(formattedData, responseFilename);
        }}
                        
        // Initialize the survey and replace the onComplete handler
        var survey = new Survey.Model(surveyJSON);
                        
        survey.locale = "{type1_locale_data["localization"]}"
        
        $jqueryselector("#surveyContainer").Survey({{
            model: survey,
            onComplete: sendDataToDisk // Replace the server submission with local saving
        }});
        
        survey.onAfterRenderQuestion.add(function (sender, options) {{
            if (options.question.name.includes('-img')) {{
                let imgElement = options.htmlElement.querySelector('#base64');
                let imageId = imgElement.src;
                initViewer(imageId);
            }} 
        }});
    </script>
</body>
""")


